#!/usr/bin/env python
from optparse import OptionParser
import sys
import httplib
import urllib
import base64
import json

LISTABLE = ['connections', 'channels', 'exchanges', 'queues', 'bindings',
            'users', 'vhosts']

def make_usage():
    usage = """usage: %prog [options] args
where args is one of:
"""
    for l in LISTABLE:
        usage += "  list %s\n" % l
    usage += """  export FILE
  import FILE"""
    return usage

parser = OptionParser(usage=make_usage())

def make_parser():
    parser.add_option("-H", "--host", dest="hostname", default="localhost",
                      help="connect to host HOST [default: %default]",
                      metavar="HOST")
    parser.add_option("-P", "--port", dest="port", default="55672",
                      help="connect to port PORT [default: %default]",
                      metavar="PORT")
    parser.add_option("-V", "--vhost", dest="vhost",
                      help="connect to vhost VHOST [default: all vhosts]",
                      metavar="VHOST")
    parser.add_option("-u", "--username", dest="username", default="guest",
                      help="connect using username USERNAME [default: %default]",
                      metavar="USERNAME")
    parser.add_option("-p", "--password", dest="password", default="guest",
                      help="connect using password PASSWORD [default: %default]",
                      metavar="PASSWORD")
    parser.add_option("-q", "--quiet", action="store_false", dest="verbose",
                      default=True, help="suppress status messages")
    parser.add_option("-f", "--format", dest="format", default="table",
                      help="format for listing commands - one of [pretty_json, raw_json, table, tsv]  [default: %default]")

def assert_usage(val):
    if not val:
        parser.print_help()
        sys.exit(1)

def main():
    make_parser()
    (options, args) = parser.parse_args()
    assert_usage(len(args) > 0)
    mgmt = Management(options, args[1:])
    mode = "invoke_" + args[0]
    assert_usage(hasattr(mgmt, mode))
    method = getattr(mgmt, "invoke_%s" % args[0])
    assert_usage(callable(method))
    method()

class Management:
    def __init__(self, options, args):
        self.options = options
        self.args = args

    def get(self, path):
        return self.http("GET", path, "")

    def put(self, path, body):
        return self.http("PUT", path, body)

    def post(self, path, body):
        return self.http("POST", path, body)

    def http(self, method, path, body):
        conn = httplib.HTTPConnection(self.options.hostname, self.options.port)
        headers = {"Authorization":
                       "Basic " + base64.b64encode(self.options.username + ":" +
                                                   self.options.password)}
        if body != "":
            headers["Content-Type"] = "application/json"
        conn.request(method, "/api%s" % path, body, headers)
        resp = conn.getresponse()
        if resp.status < 200 or resp.status >= 400:
            raise Exception("Received %d %s for path %s\n%s"
                            % (resp.status, resp.reason, path, resp.read()))
        return resp.read()

    def verbose(self, string):
        if self.options.verbose:
            print string

    def get_args(self, count):
        assert_usage(len(self.args) == count)
        return self.args

    def get_arg(self):
        return self.get_args(1)[0]

    def invoke_export(self):
        path = self.get_arg()
        config = self.get("/all-configuration")
        with open(path, 'w') as f:
            f.write(config)
        self.verbose("Exported configuration for %s to \"%s\""
                     % (self.options.hostname, path))

    def invoke_import(self):
        path = self.get_arg()
        with open(path, 'r') as f:
            config = f.read()
        self.post("/all-configuration", config)
        self.verbose("Imported configuration for %s from \"%s\""
                     % (self.options.hostname, path))

    def invoke_list(self):
        obj_type = self.get_arg()
        assert_usage(obj_type in LISTABLE)
        uri = "/%s" % obj_type
        if self.options.vhost:
            uri += "/%s" % urllib.quote_plus(self.options.vhost)
        self.format_list(self.get(uri))

    def format_list(self, json_list):
        format = self.options.format
        if format == "raw_json":
            print json_list
            return
        formatter = "format_list_" + format
        assert_usage(hasattr(self, formatter))
        method = getattr(self, formatter)
        assert_usage(callable(method))
        method(json.loads(json_list))

    def format_list_pretty_json(self, items):
        enc = json.JSONEncoder(False, False, True, True, True, 2)
        print enc.encode(items)

    def format_list_tsv(self, items):
        def ok(obj):
            return type(obj) != dict

        if len(items) > 0:
            head = ""
            item = items[0]
            for key in item:
                if ok(item[key]):
                    head += str(key) + "\t"
            self.verbose(head)

            body = ""
            for item in items:
                for key in item:
                    if ok(item[key]):
                        body += str(item[key]) + "\t"
                body += "\n"
            print body
        else:
            self.verbose("No items")

    def format_list_table(self, items):
        def ok(obj):
            return type(obj) != dict

        if len(items) > 0:
            head = []
            item = items[0]
            for key in item:
                if ok(item[key]):
                    head.append(str(key))

            rows = [head]
            for item in items:
                row = []
                for key in item:
                    if ok(item[key]):
                        row.append(str(item[key]))
                rows.append(row)
            self.ascii_table(rows)
        else:
            self.verbose("No items")

    def ascii_table(self, rows):
        table = ""
        col_widths = [0] * len(rows[0])
        for i in xrange(0, len(rows[0])):
            for j in xrange(0, len(rows)):
                col_widths[i] = max(col_widths[i], len(rows[j][i]))
        self.ascii_bar(col_widths)
        self.ascii_row(col_widths, rows[0], "^")
        self.ascii_bar(col_widths)
        for row in rows[1:]:
            self.ascii_row(col_widths, row, "<")
        self.ascii_bar(col_widths)

    def ascii_row(self, col_widths, row, align):
        txt = "|"
        for i in xrange(0, len(col_widths)):
            fmt = " {0:" + align + str(col_widths[i]) + "} "
            txt += fmt.format(row[i]) + "|"
        print txt

    def ascii_bar(self, col_widths):
        txt = "+"
        for w in col_widths:
            txt += ("-" * (w + 2)) + "+"
        print txt

if __name__ == "__main__":
    main()
